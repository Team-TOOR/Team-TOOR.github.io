---
layout: post
date: 2025-02-13
title: "운영체제 1"
tags: [study, ]
categories: [OS, ]
---
undefined<details>
  <summary>1주차</summary>



{% raw %}
```makefile
## **운영체제란 무엇인가?**
### 학습 주제
1. **운영체제의 정의**
   - 하드웨어와 소프트웨어 간의 중개자 역할.
   - 자원 관리, 사용자 인터페이스 제공.
2. **운영체제가 왜 필요한가?**
   - OS가 없다면 발생할 문제점.
   - OS가 효율성과 사용자 경험을 어떻게 개선하는지.

### 학습 자료
- 《Operating Systems: Three Easy Pieces》 Introduction.
- CS50 강의 - 운영체제 개요.

---

## **운영체제의 주요 기능**
### 학습 주제
1. **자원 관리**
   - CPU, 메모리, 디스크, 네트워크 자원의 효율적 관리.
2. **프로세스 관리**
   - 프로세스 상태(생성, 준비, 실행, 대기, 종료).
   - 프로세스 간 통신(IPC)의 기본 개념.
3. **사용자 인터페이스 제공**
   - CLI(명령줄 인터페이스)와 GUI(그래픽 사용자 인터페이스)의 차이점.

---

## **주요 운영체제의 종류**
### 학습 주제
1. **Windows**
   - GUI 중심, 사용자 친화성, 소프트웨어 호환성.
2. **Linux**
   - 오픈 소스, 높은 커스터마이징 가능성.
3. **macOS**
   - Unix 기반, 하드웨어와 소프트웨어의 높은 통합성.

---
```
{% endraw %}




  </details>

### 운영체제란?


운영체제는 하드웨어와 소프트웨어의 **중개자** 역할
사용자가 컴퓨터 하드웨어를 직접 다루지 않아도 **쉽게 작업**할 수 있도록 지원

- 주요 역할
1. **자원 관리**: 자원 (CPU, 메모리, 디스크 등..)을 효율적으로 관리함.
2. **사용자 인터페이스 제공**: CLI(Command Line Interface) 또는
 GUI(Graphical User Interface).


#### 운영체제가 왜 필요한가?


>  반대로 운영체제가 없다고 가정하고 생각…

1. 사용자가 하드웨어를 직접 제어해야 함 : 
파일을 저장하려면 디스크의 특정 섹터와 클러스터를 직접 지정해야 함.
undefined<details>
  <summary>pic</summary>


![0](/assets/img/2025-02-13-운영체제-1.md/0.png)



  </details>2. 복잡한 작업 처리에 어려움이 있음 : 
사용자나 프로그램이 충돌 없이 동시에 하드웨어를 사용하는 것이 어려움.
ex) CPU와 메모리를 수동으로 할당하고, 메모리를 해제하는 작업은 매우 복잡함.


#### 운영체제의 이점

1. 효율성 향상 : 
복잡한 하드웨어 작업을 운영체제가 대신 처리하여 사용자는 편리하게 작업 가능
ex. 네트워크를 보낼 때, 하나하나 네트워크와 통신하고 있지 않음.
2. 다중 사용자 환경 제공 : 
여러 사용자가 동시에 시스템을 사용할 수 있도록 하며, 각 사용자의 작업을 분리하고 보호함.
undefined<details>
  <summary>ex. DB</summary>


![1](/assets/img/2025-02-13-운영체제-1.md/1.png)



  </details>3. 다중 작업 환경 지원 : 
여러 프로그램이 동시에 실행 지원 
ex.  음악을 들으면서 코딩하는 것이 가능함.

> 한줄 요약 : 운영체제는 하드웨어와 소프트웨어의 중개자 역할을 하며 자원을 관리하고 사용자 인터페이스를 제공하기 위해 사용.



#### 운영체제가 없다면??


![2](/assets/img/2025-02-13-운영체제-1.md/2.png)

- 운영체제가 없다면 사용자가 하드웨어를 직접 제어해야 하므로 매우 비효율적임.

ex) 네트워크로 데이터를 전송하려면, 네트워크 장치와 직접 통신해야 합니다.


---



### 운영체제의 주요 기능



#### 자원 관리


CPU, 메모리, 디스크, 네트워크를 관리함.



#### 2. 프로세스 관리


운영체제는 실행 중인 프로그램을 **프로세스**라는 단위로 관리함.


> 프로세스 : 실행 중인 프로그램의 독립된 프로그램 단위,  
> 실행에 필요한 데이터를 포함한 **활성 상태임.**


> 프로그램 : 실행할 명령어가 포함된 코드


	![3](/assets/img/2025-02-13-운영체제-1.md/3.png)

- **프로세스의 구성 요소**
1. 프로그램 코드 : 실행할 명령어가 포함된 코드.
2. 데이터 : 실행 중인 프로그램이 처리하고 있는 데이터
3. 상태 정보 : 현재 프로세스의 상태 (ex. 시작, 대기, 종료)
- 프로세스와 프로그램의 차이

	![4](/assets/img/2025-02-13-운영체제-1.md/4.png)

- 스레드(Thread)

프로세스 내에서 실행되는 작은 단위
한 탭(프로세스) 내부에서는 페이지 로드, 사용자 입력 처리, 네트워크 요청 등(스레드)을 수행하기 위해 
여러 스레드가 사용됨.


- 프로세스와 프로그램, 스레드 비교

![5](/assets/img/2025-02-13-운영체제-1.md/5.png)

- **프로세스의 상태**

**Create** → **Ready** → **Running → Waiting → Terminated**


> 🔑 ## 상태  
> - **생성(Create)**: 새로운 프로세스가 생성됨.  
>   
> - **준비(Ready)**: 실행 대기 상태.  
>   
> - **실행(Running)**: CPU를 할당받아 실행 중.  
>   
> - **대기(Waiting)**: I/O 작업을 기다리는 상태.  
>   
> - **종료(Terminated)**: 작업이 끝난 상태. 운영체제는 프로세스가 점유한 자원을 해제

	- **생성(Create)**: 새로운 프로세스가 생성됨.
	- **준비(Ready)**: 실행 대기 상태.
	- **실행(Running)**: CPU를 할당받아 실행 중.
	- **대기(Waiting)**: I/O 작업을 기다리는 상태.
	- **종료(Terminated)**: 작업이 끝난 상태. 운영체제는 프로세스가 점유한 자원을 해제
- **프로세스 간 통신(IPC, Inter-Process Communication)**

여러 프로세스가 데이터를 교환하거나 협력할 수 있도록 지원하기 위해 사용


기법(Models) : 
Message Passing(메시지 파싱) : 


![6](/assets/img/2025-02-13-운영체제-1.md/6.png)


메시지를 A가 먼저 주고 B 되돌려 받는 방식이다.


예를 들어, 은행에 A가 입금하면 은행이 알아서 B 계좌에 입금함. (중간에 무언가 개입함 (운영체제 커널))



Shared Memory(공유 메모리) : 


![7](/assets/img/2025-02-13-운영체제-1.md/7.png)


 여러 프로세스가 같은 메모리 공간을 공유함.



#### 3. 사용자 인터페이스 제공


운영체제는 사용자와 컴퓨터 간의 상호작용을 제공함. (CLI, GUI)

- CLI (Command Line Interface)

텍스트 기반 명령을 통해 작업 수행함.


ex. 터미널

- GUI (Graphical User Interface)

그래픽 기반 인터페이스임.


ex. Windows의 바탕화면



#### 4. 주요 운영체제의 종류


대표적으로 Windows, Linux, macOS가 있음.

- **주요 운영체제**
1. **Windows**
특징 :
- GUI 중심, 사용자 친화성, 소프트웨어 호환성(그냥 많이 써서…..).

장점 :
- 게임, 상용 소프트웨어, 기업용 프로그램과의 높은 호환성
- 사용자 친화적 인터페이스

단점 :
- 유료 라이선스 필요
- 보안 취약점이 다른 운영체제에 비해 상대적으로 많음.
1. **Linux :** Unix 기반의 오픈소스 운영체제
특징 :
- 다양한 배포판, 높은 커스터마이징 → ex. Ubuntu, Fedora, Debian

장점 :
- 무료 사용 가능
- 커스터마이징 높음.
- 보안이 강력함.

단점 :
- 초보자 친화적이지 않음.
- 상용 소프트웨어 호환성 부족
1. **macOS : Apple 기기를 위한 Unix 기반 운영체제.**
특징 :
- Apple 하드웨어와 높은 통합성, 안정성과 사용자 경험 최적화됨.

장점 :
- 그래픽 디자인, 영상 편집 등 창의적인 작업에 적합.
- 안정적이고 직관적인 인터페이스

단점 :
- Apple 기기에서만 사용 가능함.
- 매우 엄청 많이 비쌈.
- **운영체제 비교**

	![8](/assets/img/2025-02-13-운영체제-1.md/8.png)



#### 5. 운영체제의 발전

- **초기 배치 처리 시스템**
1. 배치 처리 시스템 : 
한 번에 하나의 작업을 처리하는 초기 운영체제 방식

**동작 :** 작업이 끝나면 다음 작업을 순차적으로 처리함.

but. 낮은 효율성, 사용자 경험 부족해서 작업 실행 중간에 수정이나 확인이 불가능함.
- **현대 운영체제**

2-1. **멀티태스킹** (Multitasking)  : 
여러 작업이 동시에 실행되는 것처럼 보이게 만드는 기술.


![9](/assets/img/2025-02-13-운영체제-1.md/9.png)


위의 사진과 같이 작동하여 **자원 활용 증가, 사용자 경험 향상됨(**한 단계 실행중에 다음 단계 실행 가능**).**


2-2. **가상 메모리** (Virtual Memory) : 


실제 물리적 메모리(RAM)를 초과하는 데이터를 처리하기 위해 디스크를 메모리처럼 사용하는 기술

- **페이지 교체 (Page Replacement)**
물리적 메모리가 가득 차면, 현재 사용하지 않는 페이지를 디스크로 이동시키고, 
새 페이지를 물리적 메모리에 적재함.

> 페이지 : 가상 메모리의 기본 단위


> 프레임 : 물리적 메모리의 기본 단위


![10](/assets/img/2025-02-13-운영체제-1.md/10.png)


![11](/assets/img/2025-02-13-운영체제-1.md/11.png)

- **페이지 교체 (Page Replacement) 과정**
1. 프로세스는 가상 메모리의 페이지를 사용
2. 페이지는 물리적 메모리의 프레임에 매핑됨.
3. 물리적 메모리가 부족하면, 사용하지 않는 페이지가 디스크로 이동함. (스왑 아웃).
4. 필요한 페이지가 물리적 메모리에 없을 경우, 디스크에서 다시 로드됨.. (스왑 인)
undefined<details>
  <summary>설명</summary>


왼쪽 그림 : 가상 메모리임. **페이지(Page)**라는 고정 크기 블록으로 나누어져 있음.
오른쪽 그림 : 실제 컴퓨터의 RAM(메인 메모리)을 나타냄.
Disk : 가상 메모리가 실제 물리적 메모리에 모두 적재될 수 없을 때, 디스크를 임시 메모리로 사용.




  </details>- **페이지 폴트 (Page Fault):**

프로세스가 필요한 페이지가 물리적 메모리(RAM)에 없는 상황

<details>
  <summary>**Page Fault가 자주 발생하면?**</summary>


CPU 대기 시간, 디스크 I/O 증가, 
스래싱(Thrashing) 발생
(대부분의 시간을 페이지 교체에
사용하는 현상 )



  </details>
> 🔑 **Page Fault를 줄이는 방법**  
> 1. 충분한 물리적 메모리(RAM) 확보  
>   
> 2. 효율적인 페이지 교체 알고리즘 사용   
> → ex.   
> LRU(Least Recently Used) : 가장 오랫동안 사용되지 않은 페이지를 교체  
> FIFO(First-In-First-Out) : 들어온대로 나감.  
>   
> 3. 멀티태스킹 관리  
> 동시에 실행되는 프로세스 수를 줄여 메모리 자원 부담을 줄임.

	1. 충분한 물리적 메모리(RAM) 확보
	2. 효율적인 페이지 교체 알고리즘 사용 
	→ ex. 
	LRU(Least Recently Used) : 가장 오랫동안 사용되지 않은 페이지를 교체
	FIFO(First-In-First-Out) : 들어온대로 나감.
	3. 멀티태스킹 관리
	동시에 실행되는 프로세스 수를 줄여 메모리 자원 부담을 줄임.

2-3. **GUI 사용**

2-4. **네트워크 기능 추가**

- 초기 운영체제와 현대 운영체제의 차이 정리

![12](/assets/img/2025-02-13-운영체제-1.md/12.png)

- 결론

Multitasking과 Virtual Memory를 도입하며 효율성과 사용자 경험을 크게 향상됨.
GUI와 네트워크 지원은 현대 운영체제를 더욱 강력하고 직관적인 도구로 만듦.



#### 그럼 왜 아직도 운영체제 서버 환경에서 CLI를 많이 쓰는가??


> 그럼 왜 운영체제 발전에서 CLI가 서버 환경에서 여전히 많이 쓰이는 이유는 무엇인가?

- **낮은 자원 소모 :**

CLI는 그래픽 인터페이스가 필요 없기 때문에 자원을 거의 소모하지 않음.

- **빠르고 효율적인 작업 수행 :**

CLI는 **직접 명령어를 입력**하여 작업을 수행하기 때문에 GUI보다 빠르게 처리 가능

- **원격 접근 및 관리 :**

네트워크를 통해 원격으로 서버를 관리하기에 매우 적합함.


정리

- 자원을 적게 사용하고 안정성을 보장.
- 원격 접근이 쉬우며 강력한 제어력을 제공.
- GUI는 불필요하고 효율성을 떨어뜨릴 수 있음.


#### 멀티프로세싱


**여러 프로세스가 서로 독립적으로 병렬 실행**되는 방식
각 프로세스는 **독립된 메모리 공간**을 사용하며, 서로 간섭하지 않음.


ex. 실제 사용 예시
웹사이트 → 하나의 탭이 다른 탭에 영향을 미치지 않음

- 주요 특징
1. 메모리 독립성 : 
각 프로세스는 자체 메모리를 가지므로, 한 프로세스가 다른 프로세스에 영향을 미치지 않음
2. 병렬 실행 :
- 장단점

![13](/assets/img/2025-02-13-운영체제-1.md/13.png)

- 사용 예시 :
1. 웹 브라우저:

Google Chrome은 탭마다 별도의 프로세스를 생성하여, 한 탭의 충돌이 다른 탭에 영향을 미치지 않도록 설계함.

1. 운영체제:

OS는 독립적인 프로세스들(파일 시스템, 네트워크 서비스 등)을 병렬로 실행


![14](/assets/img/2025-02-13-운영체제-1.md/14.png)


사진과 같이 여러 프로세스가 공간이 분리되어 병렬로 일하고 있음.



#### 멀티스레딩(Multi-threading)


**하나의 프로세스에서 여러 스레드가 병렬로 실행**되는 방식
**동일한 메모리 공간**을 공유하며, 작업을 나눠 수행함,


![15](/assets/img/2025-02-13-운영체제-1.md/15.png)

- 주요 특징

메모리 공유, 경량성, 병렬 실행

- 장단점

![16](/assets/img/2025-02-13-운영체제-1.md/16.png)


//메모리 공유 관점에서 동기화 문제 생각해보기 + 추가

- 실제 사용 예시
1. 웹 서버 :

Apache HTTP Server는 클라이언트 요청을 처리하기 위해 멀티스레딩을 사용함.



#### 멀티프로세싱 vs 멀티스레딩


![17](/assets/img/2025-02-13-운영체제-1.md/17.png)


*오버헤드 : **어떤 처리를 하기 위해 들어가는 간접적인 처리 시간**



#### 멀티프로세싱과 멀티스레딩의 선택 기준

1. 멀티프로세싱이 적합한 경우
작업 간 독립성이 중요하고 안정성이 필요할 때

	 ex) 브라우저의 탭

1. 멀티스레딩이 적합한 경우
작업 간 데이터 공유가 많고, 빠른 통신이 필요할 때
ex) 웹 서버의 요청 처리
